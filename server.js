import express from 'express';
import cors from 'cors';
import multer from 'multer';
import dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';
import { GoogleGenAI } from "@google/genai";
import { Buffer } from "buffer";

// Load environment variables
dotenv.config({ path: '.env.local' });
dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());

// Serve static files from the build directory
app.use(express.static(path.join(process.cwd(), 'dist')));

// Serve public files (like widget.js)
app.use(express.static(path.join(process.cwd(), 'public')));

// File Upload Config
const upload = multer({
    storage: multer.memoryStorage(),
    limits: { fileSize: 5 * 1024 * 1024 } // 5MB limit
});

// --- API Logic (Inlined from externalApiService.ts) ---

const getApiClient = () => {
    const apiKey = process.env.MODEL_API_KEY;
    if (!apiKey) {
        console.warn("WARNING: MODEL_API_KEY is not set. Using placeholder.");
        return new GoogleGenAI({ apiKey: "YOUR_API_KEY_HERE" });
    }
    return new GoogleGenAI({ apiKey });
};

const bufferToBase64 = (buffer) => {
    return buffer.toString('base64');
};

const generateVirtualTryOn = async (userImageBuffer, userMimeType, productImageUrl) => {
    try {
        const ai = getApiClient();

        // Fetch product image
        const productResp = await fetch(productImageUrl);
        if (!productResp.ok) throw new Error("Failed to fetch product image from URL");
        const productArrayBuffer = await productResp.arrayBuffer();
        const productBase64 = Buffer.from(productArrayBuffer).toString('base64');
        const productMimeType = productResp.headers.get('content-type') || 'image/jpeg';

        const model = 'gemini-2.5-flash-image';
        const prompt = `
      You are a specialized Virtual Try-On AI with an obsession for product fidelity.
      
      **STRATEGIC MODE: ON**
      **INSTRUCTION: PRIORITIZE QUALITY OVER SPEED. ANALYZE IMAGE BEFORE GENERATING.**
      
      INPUTS:
      1. User Image: Target person.
      2. Product Image: The clothing item (may be worn by a model or flat lay).
      
      TASK:
      Transfer the clothing from the Product Image onto the person in the User Image.
      
      CRITICAL RULES (VIOLATION = FAILURE):
      1. **CLOTHING INTEGRITY**: The generated clothing MUST be a pixel-perfect match to the Product Image.
         - PRESERVE: Exact color, fabric texture, material weight, buttons, zippers, seams, stitching, logos, prints, and necklines.
         - **DO NOT CHANGE THE GARMENT TYPE**. If the product is a Jacket, it MUST remain a Jacket. Do not turn it into a T-Shirt.
         - If the Product Image shows a model, IGNORE the model's body/face. ONLY extract the clothing.
      
      2. **REALISTIC COMPOSITING**:
         - Warp the clothing to fit the User's pose naturally.
         - Maintain realistic lighting and shadows.
         - Do NOT alter the User's face or identity.
      
      3. **NO HALLUCINATIONS**: Do not invent new details. Do not simplify complex patterns. Copy the source material exactly.
      
      OUTPUT:
      Return ONLY the generated image.
    `;

        const response = await ai.models.generateContent({
            model: model,
            contents: {
                parts: [
                    { text: prompt },
                    {
                        inlineData: {
                            mimeType: userMimeType,
                            data: bufferToBase64(userImageBuffer)
                        }
                    },
                    {
                        inlineData: {
                            mimeType: productMimeType,
                            data: productBase64
                        }
                    }
                ]
            }
        });

        const parts = response.candidates?.[0]?.content?.parts;
        if (parts) {
            for (const part of parts) {
                if (part.inlineData && part.inlineData.data) {
                    return `data:${part.inlineData.mimeType || 'image/png'};base64,${part.inlineData.data}`;
                }
            }
        }
        throw new Error("No image generated by the external API.");

    } catch (error) {
        const apiKey = process.env.MODEL_API_KEY || '';
        let errStr = String(error);
        if (apiKey && apiKey.length > 0) {
            errStr = errStr.replace(new RegExp(apiKey, 'g'), 'YOUR_API_KEY_HERE');
        }
        console.error("External API Error:", errStr);
        throw new Error("External processing failed.");
    }
};

const generateAvatar = async (features, faceImageBuffer, faceMimeType) => {
    try {
        const ai = getApiClient();
        const model = 'gemini-2.5-flash-image';

        let prompt = `
            Generate a photorealistic, high-resolution full-body studio photo of a person with the following characteristics:
            - Gender: ${features.gender || 'Female'}
            - Age: ${features.age} years old
            - Height: ${features.height}cm
            - Weight: ${features.weight}kg
            - Body Type: ${features.bodyType} (Visual appearance)
            - Skin Tone: ${features.skinTone}
            
            The person should be standing in a neutral, relaxed pose (arms slightly away from body), facing forward.
            They should be wearing simple, neutral-colored tight-fitting clothing (like activewear or basic underwear) that reveals the body shape clearly but is modest.
            Background: Plain white or soft grey studio background.
            Lighting: Professional studio lighting, soft shadows.
            Style: Photorealistic, 8k, highly detailed texture.
        `;

        const parts = [{ text: prompt }];

        if (faceImageBuffer) {
            prompt += `
            IMPORTANT: Use the facial features (eyes, nose, mouth, structure) from the provided Face Reference Image. 
            Blend these facial features naturally onto the generated body.
            `;
            parts[0] = { text: prompt };
            parts.push({
                inlineData: {
                    mimeType: faceMimeType,
                    data: bufferToBase64(faceImageBuffer)
                }
            });
        }

        prompt += `\nReturn ONLY the generated image.`;
        parts[0] = { text: prompt };

        const response = await ai.models.generateContent({
            model: model,
            contents: { parts: parts }
        });

        const partsResp = response.candidates?.[0]?.content?.parts;
        if (partsResp) {
            for (const part of partsResp) {
                if (part.inlineData && part.inlineData.data) {
                    return `data:${part.inlineData.mimeType || 'image/png'};base64,${part.inlineData.data}`;
                }
            }
        }
        throw new Error("No avatar generated.");

    } catch (error) {
        console.error("Avatar Generation Error:", error);
        throw new Error("Failed to generate avatar.");
    }
};

// --- Routes ---

app.post('/api/generate-avatar', upload.single('face_image'), async (req, res) => {
    try {
        const features = req.body;
        const faceImage = req.file;

        if (!features.age || !features.height || !features.weight) {
            return res.status(400).json({ success: false, error: 'Missing physical characteristics' });
        }

        const avatarImage = await generateAvatar(
            features,
            faceImage ? faceImage.buffer : null,
            faceImage ? faceImage.mimetype : null
        );

        res.json({ success: true, image: avatarImage });

    } catch (error) {
        console.error("Server Error (Avatar):", error.message);
        res.status(500).json({ success: false, error: 'Avatar generation failed.' });
    }
});

app.post('/api/generate', upload.single('user_image'), async (req, res) => {
    try {
        const userImage = req.file;
        const productImageUrl = req.body.product_image_url;

        if (!userImage) return res.status(400).json({ success: false, error: 'User image is required' });
        if (!productImageUrl) return res.status(400).json({ success: false, error: 'Product image URL is required' });

        const generatedImageBase64 = await generateVirtualTryOn(
            userImage.buffer,
            userImage.mimetype,
            productImageUrl
        );

        res.json({ success: true, image: generatedImageBase64 });

    } catch (error) {
        console.error("Server Error:", error.message);
        res.status(500).json({ success: false, error: 'Processing failed. Please try again.' });
    }
});

// Catch-all handler for any request that doesn't match the above
// Using regex to avoid Express 5 PathError with wildcards
app.get(/(.*)/, (req, res) => {
    res.sendFile(path.join(process.cwd(), 'dist', 'index.html'));
});

app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
    const apiKey = process.env.MODEL_API_KEY;
    if (!apiKey) {
        console.warn("WARNING: MODEL_API_KEY is not set.");
    } else {
        const maskedKey = apiKey.length > 4
            ? apiKey.substring(0, 4) + "*".repeat(apiKey.length - 4)
            : "****";
        console.log(`API Key loaded: ${maskedKey}`);
    }
});
