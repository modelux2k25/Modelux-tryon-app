import express from 'express';
import cors from 'cors';
import multer from 'multer';
import dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';
import { GoogleGenAI } from "@google/genai";
import { Buffer } from "buffer";

// Load environment variables
dotenv.config({ path: '.env.local' });
dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());

// Serve static files from the build directory
app.use(express.static(path.join(process.cwd(), 'dist')));

// Serve public files (like widget.js)
app.use(express.static(path.join(process.cwd(), 'public')));

// File Upload Config
const upload = multer({
    storage: multer.memoryStorage(),
    limits: { fileSize: 5 * 1024 * 1024 } // 5MB limit
});

// --- API Logic (Inlined from externalApiService.ts) ---

const getApiClient = () => {
    const apiKey = process.env.MODEL_API_KEY;
    if (!apiKey) {
        console.warn("WARNING: MODEL_API_KEY is not set. Using placeholder.");
        return new GoogleGenAI({ apiKey: "YOUR_API_KEY_HERE" });
    }
    return new GoogleGenAI({ apiKey });
};

const bufferToBase64 = (buffer) => {
    return buffer.toString('base64');
};

const generateVirtualTryOn = async (userImageBuffer, userMimeType, productImageUrl) => {
    try {
        const ai = getApiClient();

        // Fetch product image
        const productResp = await fetch(productImageUrl);
        if (!productResp.ok) throw new Error("Failed to fetch product image from URL");
        const productArrayBuffer = await productResp.arrayBuffer();
        const productBase64 = Buffer.from(productArrayBuffer).toString('base64');
        const productMimeType = productResp.headers.get('content-type') || 'image/jpeg';

        const model = 'gemini-2.5-flash-image';
        const prompt = `
      You are a specialized Virtual Try-On AI with an obsession for product fidelity.
      
      **STRATEGIC MODE: ON**
      **INSTRUCTION: PRIORITIZE QUALITY OVER SPEED. ANALYZE IMAGE BEFORE GENERATING.**
      
      INPUTS:
      1. User Image: Target person.
      2. Product Image: The clothing item (may be worn by a model or flat lay).
      
      TASK:
      Transfer the clothing from the Product Image onto the person in the User Image.
      
      CRITICAL RULES (VIOLATION = FAILURE):
      1. **CLOTHING INTEGRITY**: The generated clothing MUST be a pixel-perfect match to the Product Image.
         - PRESERVE: Exact color, fabric texture, material weight, buttons, zippers, seams, stitching, logos, prints, and necklines.
         - **DO NOT CHANGE THE GARMENT TYPE**. If the product is a Jacket, it MUST remain a Jacket. Do not turn it into a T-Shirt.
         - If the Product Image shows a model, IGNORE the model's body/face. ONLY extract the clothing.
      
      2. **REALISTIC COMPOSITING**:
         - Warp the clothing to fit the User's pose naturally.
         - Maintain realistic lighting and shadows.
         - Do NOT alter the User's face or identity.
      
      3. **NO HALLUCINATIONS**: Do not invent new details. Do not simplify complex patterns. Copy the source material exactly.
      
      OUTPUT:
      Return ONLY the generated image.
    `;

        const response = await ai.models.generateContent({
            model: model,
            contents: {
                parts: [
                    { text: prompt },
                    {
                        inlineData: {
                            mimeType: userMimeType,
                            data: bufferToBase64(userImageBuffer)
                        }
                    },
                    {
                        inlineData: {
                            mimeType: productMimeType,
                            data: productBase64
                        }
                    }
                ]
            }
        });

        const parts = response.candidates?.[0]?.content?.parts;
        if (parts) {
            for (const part of parts) {
                if (part.inlineData && part.inlineData.data) {
                    return `data:${part.inlineData.mimeType || 'image/png'};base64,${part.inlineData.data}`;
                }
            }
        }
        throw new Error("No image generated by the external API.");

    } catch (error) {
        const apiKey = process.env.MODEL_API_KEY || '';
        let errStr = String(error);
        if (apiKey && apiKey.length > 0) {
            errStr = errStr.replace(new RegExp(apiKey, 'g'), 'YOUR_API_KEY_HERE');
        }
        console.error("External API Error:", errStr);
        throw new Error("External processing failed.");
    }
};

const generateAvatar = async (features, faceImageBuffer, faceMimeType) => {
    try {
        const ai = getApiClient();
        const model = 'gemini-2.5-flash-image';

        // Extract features including new measurements
        const { height, weight, age, bodyType, skinTone, gender, bust, waist } = features;

        let prompt = `
            Generate a photorealistic, high-resolution full-body studio photo of a person with the following characteristics:
            - **Gender**: ${gender || 'Female'}
            - **Age**: ${age} years old
            - **Height**: ${height} cm
            - **Weight**: ${weight} kg
            - **Body Type**: ${bodyType}
            - **Skin Tone**: ${skinTone}
            ${bust ? `- **Chest/Bust**: ${bust} cm` : ''}
            ${waist ? `- **Waist**: ${waist} cm` : ''}
            
            **CLOTHING**: The person MUST be wearing simple, tight-fitting clothing (e.g. a plain ${gender === 'Male' ? 't-shirt and shorts' : 'tank top and leggings'}) in a neutral color (white or grey) to allow for easy virtual try-on overlay later.
            
            **POSE**: Standing straight, arms slightly away from the body (A-pose or neutral standing pose), looking directly at the camera.
            **LIGHTING**: Professional studio lighting, soft shadows, neutral background.
            **QUALITY**: 8k, highly detailed, realistic skin texture.
        `;

        const parts = [{ text: prompt }];

        if (faceImageBuffer) {
            prompt += `
            IMPORTANT: Use the facial features (eyes, nose, mouth, structure) from the provided Face Reference Image. 
            Blend these facial features naturally onto the generated body.
            `;
            parts[0] = { text: prompt };
            parts.push({
                inlineData: {
                    mimeType: faceMimeType,
                    data: bufferToBase64(faceImageBuffer)
                }
            });
        }

        prompt += `\nReturn ONLY the generated image.`;
        parts[0] = { text: prompt };

        const response = await ai.models.generateContent({
            model: model,
            contents: { parts: parts }
        });

        const partsResp = response.candidates?.[0]?.content?.parts;
        if (partsResp) {
            for (const part of partsResp) {
                if (part.inlineData && part.inlineData.data) {
                    return `data:${part.inlineData.mimeType || 'image/png'};base64,${part.inlineData.data}`;
                }
            }
        }
        throw new Error("No avatar generated.");

    } catch (error) {
        console.error("Avatar Generation Error:", error);
        throw new Error("Failed to generate avatar.");
    }
};

// --- Routes ---

app.post('/api/generate-avatar', upload.single('face_image'), async (req, res) => {
    try {
        const features = req.body;
        const faceImage = req.file;

        if (!features.age || !features.height || !features.weight) {
            return res.status(400).json({ success: false, error: 'Missing physical characteristics' });
        }

        const avatarImage = await generateAvatar(
            features,
            faceImage ? faceImage.buffer : null,
            faceImage ? faceImage.mimetype : null
        );

        res.json({ success: true, image: avatarImage });

    } catch (error) {
        console.error("Server Error (Avatar):", error.message);
        res.status(500).json({ success: false, error: 'Avatar generation failed.' });
    }
});

app.post('/api/generate', upload.single('user_image'), async (req, res) => {
    try {
        const userImage = req.file;
        const productImageUrl = req.body.product_image_url;

        if (!userImage) return res.status(400).json({ success: false, error: 'User image is required' });
        if (!productImageUrl) return res.status(400).json({ success: false, error: 'Product image URL is required' });

        const generatedImageBase64 = await generateVirtualTryOn(
            userImage.buffer,
            userImage.mimetype,
            productImageUrl
        );

        res.json({ success: true, image: generatedImageBase64 });

    } catch (error) {
        console.error("Server Error:", error.message);
        res.status(500).json({ success: false, error: 'Processing failed. Please try again.' });
    }
});

// --- Endpoint: Size Estimation ---
app.post('/api/estimate-size', upload.none(), async (req, res) => {
    try {
        const { height, weight, age, bodyType, gender, bust, waist, product_image_url } = req.body;

        console.log('Size Estimation Request:', { height, weight, gender, product_image_url });

        if (!product_image_url) {
            return res.status(400).json({ success: false, error: 'Product image URL is required' });
        }

        // Fetch product image
        const imageResponse = await fetch(product_image_url);
        if (!imageResponse.ok) throw new Error("Failed to fetch product image");
        const imageArrayBuffer = await imageResponse.arrayBuffer();
        const imageBase64 = Buffer.from(imageArrayBuffer).toString('base64');
        const mimeType = imageResponse.headers.get('content-type') || 'image/jpeg';

        const prompt = `
      You are an expert fashion tailor and size advisor.
      Analyze the clothing item in the image and the user's body measurements to recommend the best size.
      
      User Profile:
      - Gender: ${gender}
      - Height: ${height} cm
      - Weight: ${weight} kg
      - Bust/Chest: ${bust || 'Not provided'} cm
      - Waist: ${waist || 'Not provided'} cm
      - Body Type: ${bodyType}
      - Age: ${age}

      Task:
      1. Identify the type of clothing in the image (e.g., T-shirt, Jacket, Dress, Pants).
      2. Estimate the fit/cut of the item (e.g., Slim fit, Oversized, Regular).
      3. Based on standard international sizing (S, M, L, XL, XXL) and Brazilian sizing (P, M, G, GG), recommend the best size for this user.
      4. Provide a short, helpful reason (max 1 sentence).

      Output Format (JSON only):
      {
        "size": "M",
        "br_size": "M",
        "details": "Based on your height and weight, M provides a tailored fit.",
        "fit_note": "This item appears to be Slim Fit."
      }
    `;

        const ai = getApiClient();
        const model = 'gemini-1.5-flash'; // Use Flash for speed

        const response = await ai.models.generateContent({
            model: model,
            contents: {
                parts: [
                    { text: prompt },
                    {
                        inlineData: {
                            mimeType: mimeType,
                            data: imageBase64
                        }
                    }
                ]
            }
        });

        const responseText = response.candidates?.[0]?.content?.parts?.[0]?.text;
        console.log('AI Size Recommendation:', responseText);

        if (!responseText) throw new Error("No recommendation generated");

        // Clean up markdown code blocks if present
        const jsonStr = responseText.replace(/```json/g, '').replace(/```/g, '').trim();
        const recommendation = JSON.parse(jsonStr);

        res.json({ success: true, recommendation });

    } catch (error) {
        console.error('AI Size Estimation Failed:', error.message);
        console.log('Switching to Mathematical Fallback...');

        // --- FALLBACK LOGIC (Measurement Based) ---
        const { height, weight, gender, bust, waist, bodyType } = req.body;

        let size = 'M';
        let br_size = 'M';
        let details = '';

        const chestVal = parseFloat(bust) || 0;
        const waistVal = parseFloat(waist) || 0;
        const heightVal = parseFloat(height) || 0;

        // Sizing Tables (Approximate in cm)
        // Men: S(88-96), M(96-104), L(104-112), XL(112+)
        // Women: S(82-88), M(88-96), L(96-104), XL(104+)

        if (chestVal > 0) {
            // Logic based primarily on Chest/Bust
            if (gender === 'Male') {
                if (chestVal < 94) { size = 'S'; br_size = 'P'; }
                else if (chestVal < 102) { size = 'M'; br_size = 'M'; }
                else if (chestVal < 110) { size = 'L'; br_size = 'G'; }
                else { size = 'XL'; br_size = 'GG'; }
            } else {
                // Female
                if (chestVal < 86) { size = 'S'; br_size = 'P'; }
                else if (chestVal < 94) { size = 'M'; br_size = 'M'; }
                else if (chestVal < 102) { size = 'L'; br_size = 'G'; }
                else { size = 'XL'; br_size = 'GG'; }
            }
            details = `Baseado no seu t처rax/busto de ${chestVal}cm.`;
        }
        else {
            // Fallback if no measurements provided (use BMI as last resort or default to M)
            // User prefers ignoring weight, but we need SOME data.
            // We'll assume M if data is missing, or use weight strictly as backup.
            if (parseFloat(weight) > 90) { size = 'L'; br_size = 'G'; }
            else if (parseFloat(weight) < 55) { size = 'S'; br_size = 'P'; }
            details = "Estimativa aproximada (adicione medidas de t처rax para precis찾o).";
        }

        // Adjust for Height (Tall people often need size up for length)
        if (heightVal > 185 && (size === 'S' || size === 'M')) {
            size = 'L'; br_size = 'G';
            details += ` Ajustado para sua altura (${heightVal}cm).`;
        }

        // Adjust for Body Type
        if (bodyType === 'Inverted Triangle' || bodyType === 'Rectangle') {
            // Broader shoulders might need more room
            if (size === 'M' && chestVal > 100) { size = 'L'; br_size = 'G'; }
        }

        const fallbackRecommendation = {
            size: size,
            br_size: br_size,
            details: details,
            fit_note: `Corte ideal para corpo ${bodyType || 'padr찾o'}.`
        };

        res.json({ success: true, recommendation: fallbackRecommendation, source: 'fallback' });
    }
});

// Catch-all handler for any request that doesn't match the above
// Using regex to avoid Express 5 PathError with wildcards
app.get(/(.*)/, (req, res) => {
    res.sendFile(path.join(process.cwd(), 'dist', 'index.html'));
});

app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
    const apiKey = process.env.MODEL_API_KEY;
    if (!apiKey) {
        console.warn("WARNING: MODEL_API_KEY is not set.");
    } else {
        const maskedKey = apiKey.length > 4
            ? apiKey.substring(0, 4) + "*".repeat(apiKey.length - 4)
            : "****";
        console.log(`API Key loaded: ${maskedKey}`);
    }
});
